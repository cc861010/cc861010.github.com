<section>
    <h2>Service Mesh</h2>
    <br>
    <br>
    <h3></h3>
    <p>
        <small>Created by <a href="#">陈超</a> / <a href="#">chenchao@99114.com</a>/2017-11-28
        </small>
    </p>
</section>

<section>
    <h2>Microservices</h2>
    <small>
        Microservices is a variant of the service-oriented architecture (SOA) architectural
        style that structures an application as a collection of loosely coupled services.
        In a microservices architecture, services should be fine-grained and the protocols
        should be lightweight. The benefit of decomposing an application into different smaller
        services is that it improves modularity and makes the application easier to understand,
        develop and test. It also parallelizes development by enabling small autonomous teams
        to develop, deploy and scale their respective services independently.It also allows the
        architecture of an individual service to emerge through continuous refactoring.
        Microservices-based architectures enable continuous delivery and deployment.
    </small>
    <br>
    <small>
        Services in a microservice architecture (MSA)[4] are often processes that communicate
        with each other over a network in order to fulfill a goal using technology-agnostic
        protocols such as HTTP. However, services might also use other kinds of
        inter-process communication mechanisms such as shared memory.[9] Services might also
        run within the same process as, for example, OSGI bundles.
        Services in a microservice architecture should be independently deployable.[10]
        The services are easy to replace.
        Services are organized around capabilities, e.g., user interface front-end,
        recommendation, logistics, billing, etc.
        Services can be implemented using different programming languages, databases,
        hardware and software environment, depending on what fits best.
        Services are small in size, messaging enabled, bounded by contexts, autonomously developed,
        independently deployable, decentralized and built and released with automated processes.
    </small>
    <br>
    <br>
    <small>References : https://en.wikipedia.org/wiki/Microservices</small>
</section>

<section>
    <h2>微服务(microservice)</h2>
    <ul>
        <li>面向服务架构service-oriented architecture (SOA)</li>
        <li>细粒度(fine-grained)</li>
        <li>协议轻量级(lightweight protocols)</li>
        <li>业务划分服务(organized around capabilities</li>
        <li>模块化(improves modularity)</li>
        <li>独立部署替换,分布式部署</li>
        <li>持续交付和部署(enable continuous delivery and deployment)</li>
    </ul>
    <p>比如:spring cloud</p>
</section>

<section>
    <h2>面向服务架构(SOA)</h2>
    <ul>
        <li>标准化接口,生命周期长</li>
        <li>服务抽象，独立，无状态</li>
        <li>服务间低耦合,正交</li>
        <li>服务发现,引用即可调用</li>
        <li>服务可组合，可重用</li>
    </ul>
    <p>比如:dubbo</p>
</section>

<section>
    <h2>微服务基本组成</h2>
    <img src="ppts/serviceMesh/m.png" width="50%" height="40%">
</section>

<section>
    <section><h2>微服务设计模式</h2></section>
    <section>
        <h2>代理设计模式</h2>
        <img src="ppts/serviceMesh/代理设计模式.png" width="50%" height="40%">
    </section>
    <section>
        <h2>分支设计模式</h2>
        <img src="ppts/serviceMesh/分支设计模式.png" width="50%" height="40%">
    </section>
    <section>
        <h2>异步消息传递设计模式</h2>
        <img src="ppts/serviceMesh/异步消息传递设计模式.png" width="50%" height="40%">
    </section>
    <section>
        <h2>数据共享设计模式</h2>
        <img src="ppts/serviceMesh/数据共享设计模式.png" width="50%" height="40%">
    </section>
    <section>
        <h2>聚合设计模式</h2>
        <img src="ppts/serviceMesh/聚合设计模式.png" width="50%" height="40%">
    </section>
    <section>
        <h2>链式设计模式</h2>
        <img src="ppts/serviceMesh/链式设计模式.png" width="50%" height="40%">
    </section>
</section>

<section>
    <h2>微服务先决条件(按照优先级从上到下)</h2>
    <ul>
        <li>计算资源的快速分配</li>
        <li>基本的监控</li>
        <li>快速部署</li>
        <li>易于分配的存储</li>
        <li>易于访问的外围</li>
        <li>认证和授权</li>
        <li>标准化的RPC</li>
    </ul>
    总结：
    <ul>
        <li>完善的微服务相关基础设施</li>
        <li>虚拟化容器化的运维自动化</li>
    </ul>
</section>

<section>
    <h2>微服务集群工具</h2>
    <ul>
        <li>千节点集群，少定制：使用开源 Kubernetes （细粒度设计，契合微服务思想）</li>
        <li>万节点集群，多定制：使用 Mesos + Marathon （双层调度好犀利）</li>
        <li>万节点集群，IT 能力强：深度定制 Kubernetes （如网易云）</li>
        <li>万节点集群，IT 能力强：深入掌握使用 DC/OS （DC/OS 在最基础的 Marathon 和 Mesos 之上添加了很多的组件）</li>
        <li>大数据集群：Spark on Mesos （建议只基于容器部署计算部分，数据部分另行部署）</li>
    </ul>
    链接：https://www.zhihu.com/question/53751176/answer/250275995
</section>

<section>
    <section>
        <h2>深入微服务</h2>
        <p>microService --> service mesh</p>
    </section>
    <section>
        <h2>简单微服务</h2>
        <img src="ppts/serviceMesh/microservice.png" width="50%" height="40%">
    </section>
    <section>
        <h2>服务发现与错误熔断</h2>
        <img src="ppts/serviceMesh/microservice1.png" width="50%" height="40%">
    </section>
    <section>
        <h2>错误熔断</h2>
        <img src="ppts/serviceMesh/hystrix-command-flow.png" width="50%" height="40%">
    </section>
    <section>
        <h2>服务发现(负载均衡)</h2>
        <ul>
            <li>客户端服务发现(client-side)</li>
            <li>服务端服务发现(server-side)</li>
            <li>后备服务发现(Lookaside)</li>
        </ul>
    </section>
    <section>
        <h2>Don't Repeat Yourself (D.R.Y)</h2>
        <img src="ppts/serviceMesh/microservice2.png" width="50%" height="40%">
    </section>
    <section>
        <h2>隔离出公共部分</h2>
        <img src="ppts/serviceMesh/microservice3.png" width="50%" height="40%">
    </section>
    <section>
        <h2>微服无形成网格(mesh)</h2>
        <img src="ppts/serviceMesh/microservice4.png" width="50%" height="40%">
    </section>
    <section>
        <h2>进一步隔离-网格透明化</h2>
        <img src="ppts/serviceMesh/microservice5.png" width="50%" height="40%">
    </section>
    <section>
        <h2>网格控制</h2>
        <img src="ppts/serviceMesh/microservice6.png" width="50%" height="40%">
    </section>
    <section>
        <h2>服务网格(service mesh)</h2>
        <img src="ppts/serviceMesh/microservice7.png" width="50%" height="40%">
    </section>
</section>

<section>
    <section data-markdown>
        ## What is Envoy
        Envoy is an L7 proxy and communication bus designed
        for large modern service oriented architectures.

        ## Goal
        The network should be transparent to applications.
        When network and application problems do occur it should
        be easy to determine the source of the problem.
    </section>
    <section>
        <h2>features</h2>
        <ul>
            <li>Out of process architecture</li>
            <li>Modern C++11 code base</li>
            <li>L3/L4/L7 filter architecture,L7 routing</li>
            <li>First class HTTP/2 (gRPC) support</li>
            <li>Service discovery</li>
            <li>Health checking</li>
            <li>Advanced load balancing</li>
            <li>Front/edge proxy support</li>
            <li>Best in class observability</li>
            <li>Dynamic configuration</li>
        </ul>
    </section>
    <section>
        <h2>Topology</h2>
        <img src="ppts/serviceMesh/microservice8.png">
    </section>

    <section>
        <h2>Front Proxy Demo</h2>
        <img src="ppts/serviceMesh/frontProxy.svg">
    </section>

    <section>
        <h4>static config</h4>
        <pre><code class="hljs" data-trim contenteditable>
version: '2'
services:

  front-envoy:
    build:
      context: ../
      dockerfile: front-proxy/Dockerfile-frontenvoy
    volumes:
      - ./front-envoy.json:/etc/front-envoy.json
    networks:
      - envoymesh
    expose:
      - "80"
      - "8001"
    ports:
      - "8000:80"
      - "8001:8001"

  service1:
    build:
      context: .
      dockerfile: Dockerfile-service
    volumes:
      - ./service-envoy.json:/etc/service-envoy.json
    networks:
      envoymesh:
        aliases:
          - service1
    environment:
      - SERVICE_NAME=1
    expose:
      - "80"

  service2:
    build:
      context: .
      dockerfile: Dockerfile-service
    volumes:
      - ./service-envoy.json:/etc/service-envoy.json
    networks:
      envoymesh:
        aliases:
          - service2
    environment:
      - SERVICE_NAME=2
    expose:
      - "80"

networks:
  envoymesh: {}

        </code></pre>
    </section>

    <section>
        <h4>front-envoy.json</h4>
        <pre><code class="hljs" data-trim contenteditable>
{
  "listeners": [
    {
      "address": "tcp://0.0.0.0:80",
      "filters": [
        {
          "name": "http_connection_manager",
          "config": {
            "codec_type": "auto",
            "stat_prefix": "ingress_http",
            "route_config": {
              "virtual_hosts": [
                {
                  "name": "backend",
                  "domains": ["*"],
                  "routes": [
                    {
                      "timeout_ms": 0,
                      "prefix": "/service/1",
                      "cluster": "service1"
                    },
                    {
                      "timeout_ms": 0,
                      "prefix": "/service/2",
                      "cluster": "service2"
                    }

                  ]
                }
              ]
            },
            "filters": [
              {
                "name": "router",
                "config": {}
              }
            ]
          }
        }
      ]
    }
  ],
  "admin": {
    "access_log_path": "/dev/null",
    "address": "tcp://0.0.0.0:8001"
  },
  "cluster_manager": {
    "clusters": [
      {
        "name": "service1",
        "connect_timeout_ms": 250,
        "type": "strict_dns",
        "lb_type": "round_robin",
        "features": "http2",
        "hosts": [
          {
            "url": "tcp://service1:80"
          }
        ]
      },
      {
        "name": "service2",
        "connect_timeout_ms": 250,
        "type": "strict_dns",
        "lb_type": "round_robin",
        "features": "http2",
        "hosts": [
          {
            "url": "tcp://service2:80"
          }
        ]
      }
    ]
  }
}


        </code></pre>
    </section>

    <section>
        <h4>service-envoy.json</h4>
        <pre><code class="hljs" data-trim contenteditable>
{
  "listeners": [
    {
      "address": "tcp://0.0.0.0:80",
      "filters": [
        {
          "name": "http_connection_manager",
          "config": {
            "codec_type": "auto",
            "stat_prefix": "ingress_http",
            "route_config": {
              "virtual_hosts": [
                {
                  "name": "service",
                  "domains": ["*"],
                  "routes": [
                    {
                      "timeout_ms": 0,
                      "prefix": "/service",
                      "cluster": "local_service"
                    }
                  ]
                }
              ]
            },
            "filters": [
              {
                "name": "router",
                "config": {}
              }
            ]
          }
        }
      ]
    }
  ],
  "admin": {
    "access_log_path": "/dev/null",
    "address": "tcp://0.0.0.0:8001"
  },
  "cluster_manager": {
    "clusters": [
      {
        "name": "local_service",
        "connect_timeout_ms": 250,
        "type": "strict_dns",
        "lb_type": "round_robin",
        "hosts": [
          {
            "url": "tcp://127.0.0.1:8080"
          }
        ]
      }
    ]
  }
}

        </code></pre>
    </section>

    <section>
        <h4>start up shell</h4>
        <pre><code class="hljs" data-trim contenteditable>
        git clone https://github.com/envoyproxy/envoy.git --depth=1
        cd envoy/examples/front-proxy/
        #启动
        sudo docker-compose -f docker-compose.yml up -d

        #envoy api
        curl http://localhost:8001/

        #service1
        curl http://localhost:8000/service/1

        #service2
        curl http://localhost:8000/service/2

        #停止
        sudo docker-compose -f docker-compose.yml down
        </code></pre>
    </section>

</section>

<section data-markdown>
    ## dynamic config (XDS)
    * Cluster Discovery Service (CDS).
    * Endpoint Discovery Service (EDS)
    * Health Discovery Service (HDS)
    * Listener Discovery Service (LDS)
    * Metric Service (MS)
    * Rate Limit Service (RLS)
    * Route Discovery Service (RDS).
    * Secret Discovery Service (SDS).
</section>

<section data-markdown>
    ## 同类产品
    * nginmesh
    * https://github.com/nginmesh/nginmesh
    * linkerd
    * https://linkerd.io
    * istio
    * https://istio.io
</section>

<section>
    <h2>nginmesh</h2>
    <img src="ppts/serviceMesh/nginx_sidecar.png" width="50%" height="40%">
</section>

<section>
    <section>
        ## Linkerd
        Linkerd is an open source network proxy designed to be deployed as a service mesh:
        a dedicated layer for managing, controlling,
        and monitoring service-to- service communication within an application.
    </section>
    <section>
        <h2>linkerd</h2>
        <img src="ppts/serviceMesh/linkerd2.png" width="50%" height="40%">
    </section>
    <section>
        <h2>linkerd</h2>
        <img src="ppts/serviceMesh/linkerd1.png" width="50%" height="40%">
    </section>
</section>

<section>
    <section data-markdown>
        ## Abstracting
        envoy  ==>  istio
    </section>
    <section>
        <h2>istio</h2>
        <img src="ppts/serviceMesh/arch.jpg" width="50%" height="40%">
    </section>
    <section data-markdown>
        ## 主要由以下组件构成
        * Envoy：Lyft开源的高性能代理总线，支持动态服务发现、负载均衡、TLS终止、HTTP/2和gPRC代理、健康检查、性能测量等功能。Envoy以sidecar的方式部署在相关的服务的Pod中。
        * Mixer：负责访问控制、执行策略并从Envoy代理中收集遥测数据。Mixer支持灵活的插件模型，方便扩展
        * Pilot：用户和Istio的接口，验证用户提供的配置和路由策略并发送给Istio组件，管理Envoy示例的生命周期
        * Istio-Auth：提供服务间和终端用户的认证机制
    </section>
    <section data-markdown>
        ## 整体功能
        * 无需对现有服务进行变更
        * 支持 http 1.1/2、gRPC 以及 TCP 流量的负载均衡和故障转移
        * 可替换的组件
        * 流量监控
        * 可提供身份认证功能
        * 可定制的路由规则
        * 错误处理，例如超时、重试、访问量控制、健康检查和熔断器等。
    </section>
    <section data-markdown>
        <h2>Pilot</h2>
        <img src="ppts/serviceMesh/pilot.png" width="50%" height="40%">
    </section>
    <section data-markdown>
        ## Pilot
        * Envoy API负责和Envoy的通讯, 主要是发送服务发现信息和流量控制规则给Envoy
        * Envoy提供服务发现，负载均衡池和路由表的动态更新的API。解耦Istio和Envoy
        * Polit定了一个抽象模型，以从特定平台细节中解耦，为跨平台提供基础
        * Platform Adapter则是这个抽象模型的现实实现版本, 用于对接外部的不同平台
        * Rules API，提供接口给外部调用以管理Pilot，包括命令行工具Istioctl以及未来可能出现的第三方管理界面
        * Abstract Model：是对服务网格中”服务”的规范表示, 即定义在istio中什么是服务，这个规范独立于底层平台。
        * Platform Adapter：这里有各种平台的实现，目前支持Kubernetes,Consul和Eureka。
    </section>
    <section data-markdown>
        ## 功能
        * 请求路由
        * 服务发现和负载均衡
        * 故障处理
        * 故障注入
        * 规则配置
    </section>
    <section data-markdown>
        <h2>Mixer</h2>
        <img src="ppts/serviceMesh/Mixer.png" width="50%" height="40%">
    </section>
    <section data-markdown>
        ## Mixer
        * 前提条件检查。允许服务在响应来自服务消费者的传入请求之前验证一些前提条件。前提条件包括认证，黑白名单，ACL检查等等。
        * 配额管理。使服务能够在多个维度上分配和释放配额。典型例子如限速。
        * 遥测报告。使服务能够上报日志和监控。
    </section>
    <section data-markdown>
        <h2>Mixer</h2>
        <img src="ppts/serviceMesh/machine.svg" width="50%" height="40%">
    </section>
    <section data-markdown>
        <h2>例子</h2>
        <img src="ppts/serviceMesh/withistio.svg" width="50%" height="40%">
    </section>

    <section data-markdown>

    </section>

</section>

<section>
    ## 完
</section>
