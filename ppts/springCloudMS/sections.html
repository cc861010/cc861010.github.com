<section>
    <h2>Spring Cloud 微服务概述</h2>
    <br>
    <br>
    <h3></h3>
    <p>
        <small>Created by <a href="#">陈超</a> / <a href="#">chenchao@99114.com</a>/2018-03-07
        </small>
    </p>
</section>

<section>
    <h2>Spring Cloud</h2>

    Spring Cloud provides tools for developers to quickly
    build some of the common patterns in distributed systems
    <br>
    <br>
    <br>
    <small>References : http://projects.spring.io/spring-cloud/#quick-start</small>
</section>

<section>
    <h2>Spring Cloud定义</h2>
    <ul>
        <li>1.提供一系列的工具</li>
        <li>2.快速开发能力</li>
        <li>3.分布式系统设计模式</li>
        <li>4.基于spring boot</li>
    </ul>
</section>

<section>
    <h2>Spring Cloud功能模块</h2>
    <ul>
        <li>configuration management</li>
        <li>service discovery</li>
        <li>circuit breakers</li>
        <li>intelligent routing</li>
        <li>micro-proxy</li>
        <li>distributed sessions</li>
        <li>control bus</li>
        <li>......</li>
    </ul>
</section>

<section>
    <h2>Spring boot: just run</h2>
    Spring Boot makes it easy to create stand-alone, production-grade
    Spring based Applications that you can "just run"
</section>

<section>
    <h2>Spring boot特点</h2>
    <ul>
        <li>1.打包优化</li>
        <li>2.依赖优化</li>
        <li>3.配置优化</li>
        <li>4.提供监控检测，监控，外部配置等应用配套功能</li>
        <li>5.快速开发</li>
        <li>6.基于spring boot</li>
    </ul>
</section>


<section>
    <h2>Spring Cloud Netflix</h2>
    Spring Cloud Netflix provides Netflix OSS integrations for Spring Boot apps
    Netflix OSS 指的是 "Netflix Open Source Software"
</section>

<section>
    <h2>一句话:</h2>
    Spring Cloud Netflix：<br>
    spring boot包装的Netflix微服务的最佳实践的框架
</section>

<section>
    <h2>Spring Cloud Netflix features:</h2>
    <ul>
        <li>Service Discovery: Eureka(etcd/consul/zookeeper)</li>
        <li>Circuit Breaker: Hystrix</li>
        <li>Declarative REST Client: Feign(JAX-RS/Spring MVC annotations)</li>
        <li>Client Side Load Balancer: Ribbon</li>
        <li>External Configuration</li>
        <li>Router and Filter: Zuul</li>
    </ul>
</section>

<section>
    <h2>微服务组</h2>
    <img src="ppts/serviceMesh/m.png" width="50%" height="40%">
</section>

<section>
    <h2>微服务特点</h2>
    <ul>
        <li>面向服务架构service-oriented architecture (SOA)</li>
        <li>细粒度(fine-grained)</li>
        <li>协议轻量级(lightweight protocols)</li>
        <li>业务划分服务(organized around capabilities</li>
        <li>模块化(improves modularity)</li>
        <li>独立部署替换,分布式部署</li>
        <li>持续交付和部署(enable continuous delivery and deployment)</li>
    </ul>
</section>

<section>
    <h2>demo项目</h2>
    http://192.168.1.40/cc/wk-ms-cloud
</section>

<section>
    <h2>Service Discovery</h2>
    <img src="ppts/springCloudMS/sd.png">
</section>

<!--<section>-->
<!--<h2>Service Discovery</h2>-->
<!--<img src="ppts/springCloudMS/cap.png" >-->
<!--</section>-->

<section>
    <h2>CAP理论:C/A/P三者不可能同时满足</h2>
    <ul>
        <li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
        <li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
        <li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
    </ul>
</section>

<section>
    <ul>
        <li>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。</li>
        <li>CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</li>
        <li>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。
        </li>
    </ul>
</section>

<section>
    <h2>微服务服务发现：AP wihtout C</h2>
    <pre><code class="hljs" data-trim contenteditable>
		<dependency>
			<groupId>com.wangku.spring.boot.etcd</groupId>
			<artifactId>spring-boot-etcd-start</artifactId>
			<version>1.0.0-SNAPSHOT</version>
		</dependency>
    </code></pre>
    <pre><code class="hljs" data-trim contenteditable>
    spring.cloud.etcd.uris: http://localhost:2379
    </code></pre>
</section>

<section>
    <section>
        <h2>Circuit Breaker:Hystrix</h2>
        <ul>
            <li>错误熔断</li>
        </ul>
    </section>
    <section>
        <h2>解决的问题：</h2>
        <ul>
            <li>某个服务A依赖30个服务,30个服务的可用性是99.99%</li>
            <li>服务A的可用性是99.99%的30次方： 99.7%</li>
            <li>0.3% of 1000 requests = 3 failures</li>
        </ul>
    </section>
    <section>
        <h2>fallback:降级</h2>
        <ul>
            <li>客户端优雅降级,切断级联</li>
        </ul>
    </section>

    <section>
        <img src="ppts/serviceMesh/hystrix-command-flow.png">
    </section>
    <section>
        <h2>Threads & Thread Pools:独立线程</h2>
        <ul>
            <li>Clients execute on separate threads.</li>
        </ul>
    </section>
    <section>
        <img src="ppts/springCloudMS/thread.png">
    </section>

    <section>
        <h2>Request collapse:请求折叠</h2>
        <ul>
            <li>multiple requests into a single back-end dependency call</li>
            <li>Use request collapsing to reduce the number of threads and network connections needed to perform concurrent</li>
        </ul>
    </section>
    <section>
        <img src="ppts/springCloudMS/window.png">
    </section>
    <section>
        <h2>Request Caching:请求缓存</h2>
    </section>
    <section>
        <img src="ppts/springCloudMS/cache.png">
    </section>
</section>

<section>
    <section>
        <h2>Client Side Load Balancer: Ribbon</h2>
        客户端负载均衡
    </section>
    <section>
        <h2>Ribbon provides the following features</h2>
        <ul>
            <li>Multiple and pluggable load balancing rules</li>
            <li>Integration with service discovery</li>
            <li>Built-in failure resiliency</li>
            <li>Clients integrated with load balancers</li>
        </ul>
    </section>
    <section>
        <h2>可插拔的负载均衡实现</h2>
        <ul>
            <li>round robin</li>
            <li>response time weighted</li>
            <li>random load balancing</li>
        </ul>
    </section>
    <section>
        <h2>集成服务发现</h2>
        <ul>
            <li>根据服务发现服务动态更新服务列表</li>
        </ul>
    </section>
    <section>
        <h2>弹性容错</h2>
        <ul>
            <li>通过IPing接口动态检测存活服务</li>
            <li>自动过滤死掉的服务</li>
            <li>根据熔断(circuit breaker pattern)过滤服务</li>
        </ul>
    </section>

    <section>
        <h2>ILoadBalancer:定义负载均衡的操作接口</h2>
        <ul>
            <li>public void addServers(ListServer newServers);</li>
            <li>public Server chooseServer(Object key);</li>
            <li>public void markServerDown(Server server);</li>
            <li>public ListServer getServerList(boolean availableOnly);</li>
            <li>public ListServer getReachableServers();</li>
            <li>public ListServer getAllServers();</li>
        </ul>
    </section>

    <section>
        <h2>IRule:负载均衡规则</h2>
        <ul>
            <li>public Server choose(Object key);</li>
            <li>public void setLoadBalancer(ILoadBalancer lb);</li>
            <li>public ILoadBalancer getLoadBalancer();</li>
        </ul>
    </section>

    <section>
        <h2>IPing:怎么样通过ping来检测服务的存活</h2>
        <ul>
            <li>public boolean isAlive(Server server)</li>
        </ul>
    </section>

    <section>
        <h2>IPing:怎么样通过ping来检测服务的存活</h2>
        <ul>
            <li>public boolean isAlive(Server server)</li>
        </ul>
    </section>

    <section>
        <h2>ServerListChangeListener:监听服务变更</h2>
        <ul>
            <li>public void serverListChanged(ListServer oldList, ListServer newList);</li>
        </ul>
    </section>

    <section>
        <h2>ServerListUpdater:服务列表动态更新</h2>
        <ul>
            <li>void serverListChanged(ListServer oldList, ListServer newList);</li>
            <li>void start(UpdateAction updateAction);</li>
            <li>void stop();</li>
            <li>String getLastUpdate();</li>
            <li>long getDurationSinceLastUpdateMs();</li>
            <li>int getNumberMissedCycles();</li>
            <li>int getCoreThreads();</li>
        </ul>
    </section>

</section>

<section>
    <section>
        <h2>GateWay: Zuul</h2>
        微服务组网关
    </section>
    <section>
        <img src="ppts/springCloudMS/zuul.png">
    </section>
    <section>
        <h2>开发Filters实现业务功能</h2>
        <ul>
            <li>Incoming</li>
            For example: authentication, dynamic routing, rate limiting, DDoS protection, metrics.
            <li>Endpoint</li>
            For example: health check responses, static error responses, 404 responses.
            <li>Outgoing</li>
            storing statistics, adding/stripping standard headers, sending events to real-time streams, gziping
            responses.
        </ul>
    </section>
</section>








